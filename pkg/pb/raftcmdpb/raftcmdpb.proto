syntax = "proto2";
package raftcmdpb;

import "metapb/metapb.proto";
import "pdpb/pdpb.proto";
import "errorpb/errorpb.proto";
import "gogoproto/gogo.proto";

option (gogoproto.marshaler_all) = true;
option (gogoproto.sizer_all) = true;
option (gogoproto.unmarshaler_all) = true;
option (gogoproto.goproto_enum_prefix_all) = false;

enum CMDType {
    Invalid = 0;
    Get     = 1;
    Put     = 3;
    Delete  = 4;
    Snap    = 5;
}

enum AdminCmdType {
    InvalidAdmin   = 0;
    ChangePeer     = 1;
    Split          = 2;
    CompactLog     = 3;
    TransferLeader = 4;
    ComputeHash    = 5;
    VerifyHash     = 6;
}

message RaftRequestHeader {
    optional uint64           cellId     = 1 [(gogoproto.nullable) = false];
    optional metapb.Peer      peer       = 2 [(gogoproto.nullable) = false];
    // true for read linearizati
    optional bool             readQuorum = 3 [(gogoproto.nullable) = false];
    // 16 bytes, to distinguish request.
    optional bytes            uuid       = 4 [(gogoproto.customname) = "UUID"];
    optional metapb.CellEpoch cellEpoch  = 5 [(gogoproto.nullable) = false];
    optional uint64           term       = 6 [(gogoproto.nullable) = false];
}

message RaftResponseHeader {
    optional errorpb.Error error       = 1 [(gogoproto.nullable) = false];
    optional bytes         uuid        = 2 [(gogoproto.customname) = "UUID"];
    optional uint64        currentTerm = 3 [(gogoproto.nullable) = false];
}

// RaftCMDRequest we can't include both normal requests and administrator request 
// at same time. 
message RaftCMDRequest {
    optional RaftRequestHeader header       = 1 [(gogoproto.nullable) = true];
    repeated Request           requests     = 2 [(gogoproto.nullable) = true];
    optional AdminRequest      adminRequest = 3 [(gogoproto.nullable) = true];
}

message RaftCMDResponse {
    optional RaftResponseHeader header        = 1 [(gogoproto.nullable) = true];
    repeated Response           responses     = 2 [(gogoproto.nullable) = true];
    optional AdminResponse      adminResponse = 3 [(gogoproto.nullable) = true];
}

message Request {
    optional CMDType type = 1 [(gogoproto.nullable) = false];;
    optional bytes   body = 2;
}

message Response {
    optional CMDType type = 1 [(gogoproto.nullable) = false];;
    optional bytes   body = 2;
}

// admin request
message AdminRequest {
    optional AdminCmdType type = 1 [(gogoproto.nullable) = false];
    optional bytes        body = 2;
}

message AdminResponse {
    optional AdminCmdType type = 1 [(gogoproto.nullable) = false];
    optional bytes        body = 2;
}

message ChangePeerRequest {
    optional pdpb.ConfChangeType changeType = 1 [(gogoproto.nullable) = false];
    optional metapb.Peer         peer       = 2 [(gogoproto.nullable) = false];
}

message ChangePeerResponse {
    optional metapb.Cell cell = 1 [(gogoproto.nullable) = false];
}

message SplitRequest {
    // This can be only called in internal RaftStore now.
    // The splitKey must be in the been splitting cell.
    optional bytes  splitKey    = 1;
    // We split the cell into two, first uses the origin 
    // parent cell id, and the second uses the new_cell_id.
    // We must guarantee that the new_cell_id is global unique.
    optional uint64 newCellID   = 2 [(gogoproto.nullable) = false];
    // The peer ids for the new split cell.
    repeated uint64 newPeerIDs  = 3;
    // If true, right cell derive the origin cell_id, 
    // left cell use new_cell_id.
    optional bool   rightDerive = 4 [(gogoproto.nullable) = false];
}

message SplitResponse {
    optional metapb.Cell left  = 1 [(gogoproto.nullable) = false];
    optional metapb.Cell right = 2 [(gogoproto.nullable) = false];
}